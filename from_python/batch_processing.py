#!/usr/bin/env python

# Crude alternative while the CollectionsManager is WIP
# Expects only 'step' subfolders in the data folder
# For each of them, compute a tet mesh with Gmsh (characteristic length factor of 0.1)
# and, if successfull, launch 'automatic_polycube'

from sys import path
from pathlib import Path
from rich.console import Console
from rich.traceback import install
from shutil import rmtree
import questionary

# Add root of HexMeshWorkshop project folder in path
project_root = str(Path(__file__).parent.parent.absolute())
if path[-1] != project_root: path.append(project_root)

# colored and detailed Python traceback
install(show_locals=True,width=Console().width,word_wrap=True)

from modules.data_folder_types import *
from modules.print_folder_as_tree import *

def print_content_and_propose_to_remove(folder: Path) -> bool:
    """
    Return true if the user asked to remove the folder (and so the folder has been removed)
    """
    print_folder_as_tree(folder)
    answser = questionary.confirm("Do you want to remove this folder ?").ask()
    assert(type(answser) == bool)
    if answser:
        rmtree(folder)
        return True
    else:
        # the user choosed to keep this folder
        return False

root_folder: root = root() # get the root data folder
for level_minus_1_folder in [x for x in root_folder.path.iterdir() if x.is_dir()]: # for each folder inside
    step_folder = AbstractDataFolder.instantiate(level_minus_1_folder) # instanciate it
    # keep only 'step' data subfolder
    if step_folder.type() != 'step':
        print(f'ignoring {level_minus_1_folder}')
        continue
    # tetrahedrization if not already done
    if not (level_minus_1_folder / 'Gmsh_0.1').exists():
        print(f"folder {level_minus_1_folder / 'Gmsh_0.1'} does not exist")
        step_folder.Gmsh(mesh_size=0.1, nb_threads=16)
    # instantiate the tet mesh folder
    tet_folder: tet_mesh = AbstractDataFolder.instantiate(level_minus_1_folder / 'Gmsh_0.1')
    assert(tet_folder.type() == 'tet_mesh')
    # 3 cases:
    # - no labeling generated by 'automatic_polycube' -> generate one
    # - a labeling was generated by 'automatic_polycube' but it is invalid or has turning-points -> remove this folder
    # - a labeling was generated by 'automatic_polycube', it is valid and doesn't have turning-points -> continue
    labeling_subfolders_generated_by_automatic_polycube: list[Path] = tet_folder.get_subfolders_generated_by('automatic_polycube')
    assert(len(labeling_subfolders_generated_by_automatic_polycube) <= 1)
    if len(labeling_subfolders_generated_by_automatic_polycube) == 0:
        tet_folder.automatic_polycube(False,True)
        labeling_subfolders_generated_by_automatic_polycube: list[Path] = tet_folder.get_subfolders_generated_by('automatic_polycube')
        if len(labeling_subfolders_generated_by_automatic_polycube) == 0:
            # failed again
            continue
    labeling_folder: Optional[labeling] = None
    try:
        labeling_folder = AbstractDataFolder.instantiate(labeling_subfolders_generated_by_automatic_polycube[0])
    except:
        # there is a subfolder generated by 'automatic_polycube', but it is not instanciable -> algo failed to generate a labeling file
        print(f'automatic_polycube failed to generate a labeling in {labeling_subfolders_generated_by_automatic_polycube[0]}. Content of the folder:')
        if print_content_and_propose_to_remove(labeling_subfolders_generated_by_automatic_polycube[0]):
            tet_folder.automatic_polycube(False,True)