#!/usr/bin/env python

# Analysis of the subfolders generated by 'batch_processing.py'

from sys import path
from pathlib import Path
from rich.console import Console
from rich.traceback import install
import logging
from time import localtime, strftime
from json import dumps

# Add root of HexMeshWorkshop project folder in path
project_root = str(Path(__file__).parent.parent.absolute())
if path[-1] != project_root: path.append(project_root)

# colored and detailed Python traceback
install(show_locals=True,width=Console().width,word_wrap=True)

from modules.data_folder_types import *

logging.getLogger().setLevel(logging.INFO)

report_name = strftime('%Y-%m-%d_%Hh%M_report', localtime())

nb_CAD = 0
nb_meshing_fails = 0
nb_meshing_successes = 0
nb_labelings_failed = 0
nb_labelings_invalid = 0
nb_labelings_valid_with_turning_points = 0
nb_labelings_valid_no_turning_points = 0

AG_Grid_rowData = list()

# parse the current data folder,
# count tet meshes, failed/invalid/valid labelings,
# and fill `AG_Grid_rowData`

root_folder = root()
for level_minus_1_folder in [x for x in root_folder.path.iterdir() if x.is_dir()]:
    CAD_name = level_minus_1_folder.name
    if not (level_minus_1_folder / step.FILENAMES.STEP).exists():
        logging.warning(f"Folder {level_minus_1_folder} has no {step.FILENAMES.STEP}")
        continue
    nb_CAD += 1
    if (level_minus_1_folder / 'Gmsh_0.1/').exists() and (level_minus_1_folder / 'Gmsh_0.1' / tet_mesh.FILENAMES.SURFACE_MESH_OBJ).exists():
        tet_folder: tet_mesh = AbstractDataFolder.instantiate(level_minus_1_folder / 'Gmsh_0.1')
        nb_meshing_successes += 1
        avg_edge_length = float(tet_folder.get_mesh_stats_dict()['edges']['length']['avg'])
        labeling_subfolders_generated_by_automatic_polycube: list[Path] = tet_folder.get_subfolders_generated_by('automatic_polycube')
        assert(len(labeling_subfolders_generated_by_automatic_polycube) <= 1)
        if len(labeling_subfolders_generated_by_automatic_polycube) == 0:
            nb_labelings_failed += 1
            current_row = dict()
            current_row['name'] = CAD_name
            current_row['avg_edge_length'] = avg_edge_length
            current_row['valid'] = None # will be converted to JSON/Javascript 'null'
            current_row['nb_turning_points'] = None
            current_row['percentage_removed'] = None
            current_row['percentage_lost'] = None
            current_row['percentage_preserved'] = None
            current_row['folder'] = str(tet_folder.path)
            AG_Grid_rowData.append(current_row)
            continue
        relative_path = labeling_subfolders_generated_by_automatic_polycube[0].relative_to(root_folder.path)
        if not (labeling_subfolders_generated_by_automatic_polycube[0] / labeling.FILENAMES.SURFACE_LABELING_TXT).exists():
            nb_labelings_failed += 1 # case combine with the one where there is no folder generated by `automatic_polycube`
            current_row = dict()
            current_row['name'] = CAD_name
            current_row['avg_edge_length'] = avg_edge_length
            current_row['valid'] = None
            current_row['nb_turning_points'] = None
            current_row['percentage_removed'] = None
            current_row['percentage_lost'] = None
            current_row['percentage_preserved'] = None
            current_row['folder'] = str(tet_folder.path)
            AG_Grid_rowData.append(current_row)
            continue
        labeling_folder: labeling = AbstractDataFolder.instantiate(labeling_subfolders_generated_by_automatic_polycube[0])
        assert(labeling_folder.type() == 'labeling')
        feature_edges_stats = labeling_folder.get_labeling_stats_dict()['feature-edges']
        total_feature_edges = feature_edges_stats['removed'] + feature_edges_stats['lost'] + feature_edges_stats['preserved']
        current_row = dict()
        current_row['name'] = CAD_name
        current_row['avg_edge_length'] = avg_edge_length
        current_row['valid'] = labeling_folder.has_valid_labeling()
        current_row['nb_turning_points'] = labeling_folder.nb_turning_points()
        current_row['percentage_removed'] = feature_edges_stats['removed']/total_feature_edges*100
        current_row['percentage_lost'] = feature_edges_stats['lost']/total_feature_edges*100
        current_row['percentage_preserved'] = feature_edges_stats['preserved']/total_feature_edges*100
        current_row['folder'] = str(labeling_subfolders_generated_by_automatic_polycube[0])
        AG_Grid_rowData.append(current_row)
        if not labeling_folder.has_valid_labeling():
            nb_labelings_invalid += 1
            continue
        if labeling_folder.nb_turning_points() != 0:
            nb_labelings_valid_with_turning_points += 1
            continue
        nb_labelings_valid_no_turning_points += 1
    else:
        # not even a surface mesh
        nb_meshing_fails += 1
        current_row = dict()
        current_row['name'] = CAD_name
        current_row['avg_edge_length'] = None
        current_row['valid'] = None
        current_row['nb_turning_points'] = None
        current_row['percentage_removed'] = None
        current_row['percentage_lost'] = None
        current_row['percentage_preserved'] = None
        current_row['folder'] = str(level_minus_1_folder)
        AG_Grid_rowData.append(current_row)

assert(nb_meshing_fails + nb_meshing_successes == nb_CAD)
assert(nb_labelings_failed + nb_labelings_invalid + nb_labelings_valid_with_turning_points + nb_labelings_valid_no_turning_points == nb_meshing_successes)

# Define nodes & links of the Sankey diagram

Sankey_diagram_data = dict()
Sankey_diagram_data["nodes"] = list()
Sankey_diagram_data["nodes"].append({"node":0,"name":f"{nb_CAD} CAD models"})
Sankey_diagram_data["nodes"].append({"node":1,"name":f"meshing successes : {nb_meshing_successes/nb_CAD*100:.2f} %"})
Sankey_diagram_data["nodes"].append({"node":2,"name":f"labelings failed : {nb_labelings_failed/nb_meshing_successes*100:.2f} %"})
Sankey_diagram_data["nodes"].append({"node":3,"name":f"labelings invalid : {nb_labelings_invalid/nb_meshing_successes*100:.2f} %"})
Sankey_diagram_data["nodes"].append({"node":4,"name":f"labelings non-monotone : {nb_labelings_valid_with_turning_points/nb_meshing_successes*100:.2f} %"})
Sankey_diagram_data["nodes"].append({"node":5,"name":f"labelings OK : {nb_labelings_valid_no_turning_points/nb_meshing_successes*100:.2f} %"})
if nb_meshing_fails != 0:
    # add a node for failed tet mesh generation
    Sankey_diagram_data["nodes"].append({"node":6,"name":f"meshing failed : {nb_meshing_fails/nb_CAD*100:.2f} %"})
Sankey_diagram_data["links"] = list()
Sankey_diagram_data["links"].append({"source":0,"target":1,"value":nb_CAD})
Sankey_diagram_data["links"].append({"source":1,"target":2,"value":nb_labelings_failed})
Sankey_diagram_data["links"].append({"source":1,"target":3,"value":nb_labelings_invalid})
Sankey_diagram_data["links"].append({"source":1,"target":4,"value":nb_labelings_valid_with_turning_points})
Sankey_diagram_data["links"].append({"source":1,"target":5,"value":nb_labelings_valid_no_turning_points})
if nb_meshing_fails != 0:
    # add a link 'CAD models -> meshing failed'
    Sankey_diagram_data["nodes"].append({"source":0,"target":6,"value":nb_meshing_fails})

# Assemble the HTML file

HTML_report = """<!DOCTYPE html>
<html lang="en">
	<head>
		<title>""" + report_name + """</title>
		<meta charSet="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1"/>
		<style media="only screen">
            html, body {
                height: 100%;
                width: 100%;
                margin: 0;
                box-sizing: border-box;
                -webkit-overflow-scrolling: touch;
            }

            html {
                position: absolute;
                top: 0;
                left: 0;
                padding: 0;
                overflow: auto;
            }

            body {
                padding: 16px;
                overflow: auto;
                background-color: #181d1f;
            }

            body details {
                color: white;
                text-align: center;
            }

            /* for the Sankey diagram */
            .link {
                fill: none;
                stroke: white;
                stroke-opacity: .2;
            }
            .link:hover {
                stroke-opacity: .5;
            }
            </style>
	</head>
	<body>
        <details>
            <summary>Sankey diagram</summary>
            <div id="sankey"></div>
        </details>
		<div id="myGrid" style="width: 100%; height: 98%" class="ag-theme-alpine-dark"></div>
		<script src="https://cdn.jsdelivr.net/npm/ag-grid-community@31.1.1/dist/ag-grid-community.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.11/dist/clipboard.min.js"></script>
        <script src="https://d3js.org/d3.v4.min.js"></script> <!-- Load d3.js -->
        <script src="https://cdn.jsdelivr.net/gh/holtzy/D3-graph-gallery@master/LIB/sankey.js"></script><!-- Load the sankey.js function -->
		<script>
            // clipboard.js
            new ClipboardJS('.btn');

            function getViewCommand(params) {
                return "./view -i " + params.data.folder
            }

            class CustomButtonComponent {
                eGui;
                eButton;

                init(params) {
                    this.eGui = document.createElement('div');
                    this.eGui.classList.add('custom-element');
                    this.eGui.innerHTML = `
                        <button class="btn" data-clipboard-text="${getViewCommand(params)}">
                            Copy
                        </button>
                    `;
                }

                getGui() {
                    return this.eGui;
                }

                refresh(params) {
                    return false;
                }
            }

            // thanks Bamdad Fard https://blog.ag-grid.com/formatting-numbers-strings-currency-in-ag-grid/
            function floatingPointFormatter(params) {
                return params.value == null ? null : params.value.toFixed(2);
            }

            // Grid API: Access to Grid API methods
            let gridApi;

            // Grid Options: Contains all of the grid configurations
            const gridOptions = {
                // Row Data: The data to be displayed.
                rowData: """ + dumps(AG_Grid_rowData) + """,
                // Column Definitions: Defines & controls grid columns.
                columnDefs: [
                    { field: "name", headerName: "CAD model", cellDataType: 'text', filter: true },
                    {
                        headerName: 'tet mesh',
                        children: [
                            { field: "avg_edge_length", headerName: "avg. edge length", cellDataType: 'number', valueFormatter: floatingPointFormatter, filter: true },
                        ]
                    },
                    {
                        headerName: 'labeling',
                        children: [
                            { field: "valid",               headerName: "valid",            cellDataType: 'boolean', filter: true },
                            { field: "nb_turning_points",   headerName: "#turning-points",  cellDataType: 'number', filter: true },
                        ]
                    },
                    {
                        headerName: 'feature edges',
                        children: [
                            { field: "percentage_removed",      headerName: "%age removed",     cellDataType: 'number', valueFormatter: floatingPointFormatter, filter: true },
                            { field: "percentage_lost",         headerName: "%age lost",        cellDataType: 'number', valueFormatter: floatingPointFormatter, filter: true },
                            { field: "percentage_preserved",    headerName: "%age preserved",   cellDataType: 'number', valueFormatter: floatingPointFormatter, filter: true },
                        ]
                    },
                    { field: 'command', headerName: "'view' command", cellRenderer: CustomButtonComponent },
                ]
            };

            // Create Grid: Create new grid within the #myGrid div, using the Grid Options object
            gridApi = agGrid.createGrid(document.querySelector('#myGrid'), gridOptions);

            ///////// Sankey diagram /////////////////////////////////

            // set the dimensions and margins of the graph
            var margin = {top: 10, right: 10, bottom: 50, left: 10},
            width = 1200 - margin.left - margin.right,
            height = 800 - margin.top - margin.bottom;

            // append the svg object to the body of the page
            var svg = d3.select("#sankey").append("svg")
                .attr("width", width + margin.left + margin.right)
                .attr("height", height + margin.top + margin.bottom)
                .append("g")
                .attr("transform",
                    "translate(" + margin.left + "," + margin.top + ")");

            // Color scale used
            var color = d3.scaleOrdinal(d3.schemeCategory20);

            // Set the sankey diagram properties
            var sankey = d3.sankey()
                .nodeWidth(36)
                .nodePadding(50)
                .size([width, height]);

            graph = """ + dumps(Sankey_diagram_data) + """

            // Constructs a new Sankey generator with the default settings.
            sankey
                .nodes(graph.nodes)
                .links(graph.links)
                .layout(1);

            // add in the links
            var link = svg.append("g")
                .selectAll(".link")
                .data(graph.links)
                .enter()
                .append("path")
                .attr("class", "link")
                .attr("d", sankey.link() )
                .style("stroke-width", function(d) { return Math.max(1, d.dy); })
                .sort(function(a, b) { return b.dy - a.dy; });

            // add in the nodes
            var node = svg.append("g")
                .selectAll(".node")
                .data(graph.nodes)
                .enter().append("g")
                .attr("class", "node")
                .attr("transform", function(d) { return "translate(" + d.x + "," + d.y + ")"; })
                .call(d3.drag()
                    .subject(function(d) { return d; })
                    .on("start", function() { this.parentNode.appendChild(this); })
                    .on("drag", dragmove));

            // add the rectangles for the nodes
            node
                .append("rect")
                .attr("height", function(d) { return d.dy; })
                .attr("width", sankey.nodeWidth())
                .style("fill", function(d) { return d.color = color(d.name.replace(/ .*/, "")); })
                .style("stroke", function(d) { return d3.rgb(d.color).darker(2); })
                // Add hover text
                .append("title")
                .text(function(d) { return d.name + """ + r'"\n"' + """ + "There is " + d.value + " items in this node"; });

            // add in the title for the nodes
                node
                .append("text")
                .style("fill", "white")
                .attr("x", -6)
                .attr("y", function(d) { return d.dy / 2; })
                .attr("dy", ".35em")
                .attr("text-anchor", "end")
                .attr("transform", null)
                .text(function(d) { return d.name; })
                .filter(function(d) { return d.x < width / 2; })
                .attr("x", 6 + sankey.nodeWidth())
                .attr("text-anchor", "start");

            // the function for moving the nodes
            function dragmove(d) {
                d3.select(this)
                .attr("transform",
                        "translate("
                        + d.x + ","
                        + (d.y = Math.max(
                            0, Math.min(height - d.dy, d3.event.y))
                            ) + ")");
                sankey.relayout();
                link.attr("d", sankey.link() );
            }

            SankeyChart({nodes,links})

		</script>
	</body>
</html>
"""

with open(f'{report_name}.html','w') as HTML_file:
    logging.info(f'Writing {report_name}.html...')
    HTML_file.write(HTML_report)