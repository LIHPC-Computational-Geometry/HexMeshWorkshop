#pragma once

#include <iostream>
#include <filesystem>
#include <fstream>
#include <nlohmann/json.hpp>
#include <string>
#include <initializer_list>

#include "paths.h"
#include "mesh_stats.h"

class InfoFile {

public:
    InfoFile(std::filesystem::path path, bool append = false) : _path(path) {
        if(append) {
            std::ifstream ifs(path);
            if(ifs.is_open()) {
                ifs >> _json;
                ifs.close();
            }
        }
    }

    ~InfoFile() {
        std::ofstream ofs(_path);
        if(ofs.is_open()) {
            ofs << std::setw(4) << _json << std::endl;
            ofs.close();
        }
        else {
            std::cerr << "Error : in InfoFile(), unable to write " << _path.string() << std::endl;
        }
    }

    template <typename T>
    void add_entry(std::initializer_list<std::string> keys, T value) {
        //assemble the full json pointer by concatenating the keys
        std::string json_pointer_str = "";
        for(auto* key_name = keys.begin(); key_name != keys.end(); ++key_name) {
            json_pointer_str += "/" + (*key_name);
        }
        //write in _json object
        _json[nlohmann::json::json_pointer(json_pointer_str)] = value;
    }

    void generated_by(std::string value) {
        add_entry({"generated_by"},value);
    }

    void comments(std::string value) {
        add_entry({"comments"},value);
    }

    void date(std::string value) {
        add_entry({"date"},value);
    }

private:
    std::filesystem::path _path;
    nlohmann::json _json;
};



class TetraMeshInfo : public InfoFile {

public:
    TetraMeshInfo(std::filesystem::path path) : InfoFile(path) {}

    void vertices(int value) {
        add_entry({"vertices"},value);
    }

    void tetrahedra(int value) {
        add_entry({"tetrahedra"},value);
    }

    void surface_vertices(int value) {
        add_entry({"surface_vertices"},value);
    }

    void surface_triangles(int value) {
        add_entry({"surface_triangles"},value);
    }

    //parameter of NETGEN & MeshGems
    void max_mesh_size_of(std::string algorithm, float value) {
        add_entry({algorithm,"max_mesh_size"},value);
    }

    //parameter of GMSH
    void size_factor_of(std::string algorithm, float value) {
        add_entry({algorithm,"size_factor"},value);
    }

    void fill_from(const TetraMeshStats& mesh_stats) {
        vertices(mesh_stats.get_nb_vertices());
        tetrahedra(mesh_stats.get_nb_tetrahedra());
        surface_vertices(mesh_stats.get_nb_surface_vertices());
        surface_triangles(mesh_stats.get_nb_surface_triangles());
    }

};


class LabelingInfo : public InfoFile {

public:
    LabelingInfo(std::filesystem::path path) : InfoFile(path) {}

    void fidelity(double value) {
        add_entry({"fidelity"},value);
    }

    void charts(int value) {
        add_entry({"charts"},value);
    }

    void boundaries(int value) {
        add_entry({"boundaries"},value);
    }

    void corners(int value) {
        add_entry({"corners"},value);
    }

    void turning_points(int value) {
        add_entry({"turning-points"},value);
    }

    void invalid_charts_score(int value) {
        add_entry({"invalid_charts_score"},value);
    }

    void invalid_boundaries_score(int value) {
        add_entry({"invalid_boundaries_score"},value);
    }

    void invalid_corners_score(int value) {
        add_entry({"invalid_corners_score"},value);
    }

    void total_invalidity_score(int value) {
        add_entry({"total_invalidity_score"},value);
    }

    void relaxed_invalid_corners_score(int value) {
        add_entry({"relaxed_invalid_corners_score"},value);
    }

    //parameter of graph-cut
    void compactness_of(std::string algorithm, int value) {
        add_entry({algorithm,"compactness"},value);
    }

    //parameter of graph-cut
    void fidelity_of(std::string algorithm, int value) {
        add_entry({algorithm,"fidelity"},value);
    }

    //return 1 = error, return 0 = worked
    //invalid_corner_score_is_relaxed is true for logs.json of evolabel, false for the ones of evolabel_tweaked
    bool fill_from(std::filesystem::path path, bool invalid_corner_score_is_relaxed = false) {
        std::ifstream ifs(path);
        if(!ifs.is_open()) {
            std::cerr << "Error : unable to read '" << path.string() << "'" << std::endl;
            return 1;
        }
        if(path.extension() == ".txt") {
            //fill from a labeling_stats.txt file generated by genomesh/labeling_stats app
            std::string line, key, value;
            while (getline(ifs,line)) {
                if(line.empty()) {
                    continue;
                }
                else if (line[0] == '#') {
                    continue;
                }
                int separator_index = line.find('=');
                key = line.substr(0,separator_index);//what is before '='
                value = line.substr(separator_index+1);//what is after '='
                if(key == "fidelity") {
                    fidelity(std::stod(value));
                }
                else if(key == "nb_corners") {
                    corners(std::stoi(value));
                }
                else if(key == "nb_charts") {
                    charts(std::stoi(value));
                }
                else if(key == "nb_boundaries") {
                    boundaries(std::stoi(value));
                }
                else if(key == "nb_turning_points") {
                    turning_points(std::stoi(value));
                }
                else if(key == "invalid_charts_score") {
                    invalid_charts_score(std::stoi(value));
                }
                else if(key == "invalid_boundaries_score") {
                    invalid_boundaries_score(std::stoi(value));
                }
                else if(key == "invalid_corners_score") {
                    invalid_corners_score(std::stoi(value));
                }
                else if(key == "total_invalidity_score") {
                    total_invalidity_score(std::stoi(value));
                }
                else if(key == "relaxed_invalid_corners_score") {
                    relaxed_invalid_corners_score(std::stoi(value));
                }
            }
        }
        else if(path.extension() == ".json") {
            //fill from a logs.json file generated by evocube/evolabel app
            nlohmann::json logs;
            ifs >> logs;
            fidelity(std::stod(logs.value("/LabelingFinal/fidelity"_json_pointer,"-1")));
            corners(std::stoi(logs.value("/LabelingFinal/#corners"_json_pointer,"-1")));
            charts(std::stoi(logs.value("/LabelingFinal/#charts"_json_pointer,"-1")));
            // the number of boundaries is not in logs.json
            turning_points(std::stoi(logs.value("/LabelingFinal/#tps"_json_pointer,"-1")));
            invalid_charts_score(std::stoi(logs.value("/LabelingFinal/InvalidCharts"_json_pointer,"-1")));
            invalid_boundaries_score(std::stoi(logs.value("/LabelingFinal/InvalidBorders"_json_pointer,"-1")));
            if(invalid_corner_score_is_relaxed) {
                relaxed_invalid_corners_score(std::stoi(logs.value("/LabelingFinal/InvalidCorners"_json_pointer,"-1")));
            }
            else {
                relaxed_invalid_corners_score(std::stoi(logs.value("/LabelingFinal/InvalidCorners"_json_pointer,"-1")));
                total_invalidity_score(std::stoi(logs.value("/LabelingFinal/InvalidTotal"_json_pointer,"-1")));
            }
        }
        ifs.close();
        return 0;
    }
};


class HexMeshInfo : public InfoFile {

public:
    //HexMeshInfo interface a JSON file that can contain info of multiple hex meshes,
    //but each instance of HexMeshInfo write info of a single hex mesh : hex_mesh_filename
    HexMeshInfo(std::filesystem::path path, std::string hex_mesh_filename) : 
        InfoFile(path,true), //append mode, because it could the info of a 2nd hex mesh, and we want to keep the info of the 1st one
        _hex_mesh_filename(hex_mesh_filename) {} 

    //redefinition of generated_by, comments and date, which are no longer top-level keys
    void generated_by(std::string value) {
        add_entry({_hex_mesh_filename,"generated_by"},value);
    }

    void comments(std::string value) {
        add_entry({_hex_mesh_filename,"comments"},value);
    }

    void date(std::string value) {
        add_entry({_hex_mesh_filename,"date"},value);
    }

    void vertices(int value) {
        add_entry({_hex_mesh_filename,"vertices"},value);
    }

    void hexahedra(int value) {
        add_entry({_hex_mesh_filename,"hexahedra"},value);
    }

    void min_SJ(double value) {
        add_entry({_hex_mesh_filename,"min_SJ"},value);
    }

    //parameter of polycube_withHexEx & robustPolycube (rb_generate_quantization)
    void scale_of(std::string algorithm, float value) {
        add_entry({_hex_mesh_filename,algorithm,"scale"},value);
    }

    //parameter of postprocess
    void input_of(std::string algorithm, std::string value) {
        add_entry({_hex_mesh_filename,algorithm,"input"},value);
    }

    void fill_from(const HexMeshStats& mesh_stats) {
        vertices(mesh_stats.get_nb_vertices());
        hexahedra(mesh_stats.get_nb_hexahedra());
        min_SJ(mesh_stats.get_min_SJ());
    }

private:
    std::string _hex_mesh_filename;

};